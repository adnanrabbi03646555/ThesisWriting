\chapter{Introduction}
\label{chapter:Introduction}
Security is one of the important factors in software development. Developing secure system is not an easy task and only adding some information flow restrictions is not sufficient. Now-a-days detection of information flow vulnerabilities in code is particularly one of the challenging issues. There is no common annotation language for annotating UML state charts and source code with information flow security constraints such that errors can be detected when code is not available. In addition, there are
no automated checking tools which can reuse the annotated constraints in early stages of software development phase to check information flow errors. It is important to specify security constraints as early as possible in the software development phase in order to avoid the later stage costly repairs or exploitable vulnerabilities.

A solution for tagging sanitization, declassification and authentication in source code is based on libraries which contain all required annotations attached to function declarations. This approach plays an important role mainly for static analysis bug detection techniques where the information is available during program run-time. Detection of information flow vulnerabilities uses dynamic analysis techniques, static analysis techniques and hybrid techniques combining both static and dynamic approaches. The static technique needs to know when to use  sanitization, declassification and authentication functions.

Data sanitization has been studied in the context of architectures for high assurance systems, language-based information flow controls and privacy-preserving data publication \cite{ref_1_gehani2011f}. A global policy of noninterference which ensures that high security data will not be observable on low-security channels. This is because noninterference is typically a very strong property, most programs use some form of declassification to selectively leak high security  information \cite{ref_2_hicks2006trusted}. Declassification is often expressed as an operation within a given
program. Authentication is the way through which the users get access to a system. In this research, the main focus are these three types of functionalities which are sanitization, declassification and authentication errors in UML state charts. 

Web applications are often implemented by developers with limited security skills and that's why they contain vulnerabilities. Most of these vulnerabilities come from the lack of input validation. That is, web applications use malicious input as part of a sensitive operation, without having properly checked or sanitized the input values
prior to their use. Another function is declassification. Computing systems often deliberately release (or declassify) sensitive information. The main security concern for systems permitting information release is whether this release is safe or not. Now-a-days computing systems release sensitive information by classifying the basic goals according to what information is released, who releases information, where in the system information is released and when information can be released. In case of authentication, it is the mechanism which actually confirms the identity of users trying to access a system (application, login verification into a system, database access etc.). 

It is important to develop techniques and tools which can detect information flow type of errors before software developers or programmers develop their production code. Information flow errors in UML models and code are introduced by software developers or programmers who are sometimes unaware or blind while developing software. This type of vulnerabilities are hard to detect because static code analysis techniques need previous knowledge about what should be considered as a security issue. Code annotations which are added mainly during software development \cite{ref_18_chess2004static} can be used to provide additional knowledge regarding security issues. Code annotations can increase the number of source code lines by 10\%. In order to detect information flow vulnerabilities, software artifacts have to be annotated with annotations attached to public data, private data and to system trust boundaries. Furthermore, annotated artifacts have to be made tractable by tools which can use the annotations and check if information flow constraints hold or not based on information propagation techniques.

Static Checking is a promising research area which tries to cope with the shortage of not having the program run-time information. During extended static analysis, additional information is provided to the static analysis process. This information can be used to define trust boundaries and tag variables. Textual annotations are usually added manually by the user in the source code. At the same time annotations can be automatically generated and inserted into source code. Static Checking can be used to eliminate bugs in the later stage of the software project when code development is finished. Tagging and checking for information exposure bugs during the design phase would eliminate software bugs which can be very expensive afterwards. Thus, security concerns should be enforced into source code right after the conceptual phase of the project.

Current standard security practices do not provide
substantial assurance that the end-to-end behavior of a
computing system satisfies important security policies such as
confidentiality. An end-to-end confidentiality policy might assert
that secret input data cannot be inferred by an attacker through
the attacker's observations of system output; this policy regulates
information flow.
Conventional security mechanisms such as access control
and encryption do not directly address the enforcement of
information-flow policies. Recently, a promising new approach
has been developed which is the use of programming-language techniques
for specifying and enforcing information flow policies.
The past three decades of research on
information flow security, particularly focusing on work that uses
static program analysis to enforce information flow policies. 

There is little assurance that
current computing systems protect data confidentiality and
integrity; existing theoretical frameworks for expressing these
security properties are inadequate and practical techniques for
enforcing these properties are unsatisfactory. Language-based mechanisms are especially interesting because
the standard security mechanisms are unsatisfactory
for protecting confidential information in the emerging, large
networked information systems. Military, medical and financial
information systems, as well as web-based services such
as mail, shopping and business-to-business transactions are
applications that create serious privacy questions for which
there are no good answers at present.

The standard way to protect confidential data is access control: some privilege is required in order to
access files or objects containing the confidential data. Access
control checks place restrictions on the release of information
but not its propagation. Once information is released from
its container, the accessing program may improperly transmit the information in some form. It is
unrealistic to assume that all the programs in a large computing
system are trustworthy; security mechanisms such as signature
verification and antivirus scanning do not provide assurance
that confidentiality is maintained by the checked program. To
ensure that information is used only in accordance with the
relevant confidentiality policies, it is necessary to analyze how
information flows within the used program.

Annotations can cover design decisions and enhance the quality of source code. Annotations are necessary in order to do static checking and the user needs a kind of assistance tool that helps selecting the suited annotation based on the current context. At the same time adding annotations to reusable code libraries reduces even more annotation burden since libraries can be reused, shared and changed by software development teams.

In summary the contribution of this research are:
\begin{itemize}
 \item A light-weight security annotation language
	used to define information flow constraints regarding authentication, declassification and santization function errors in UML state charts and source code.
	
\item Annotation language editor designed as eclipse
	plug-in which is used to edit UML state charts and
	source code files.
	
\item Source code generator developed as eclipse plug-in which is used to generate C code with header files from UML state chart.

\item Three checkers are implemented inside our static analysis engine.
	
\item Textual annotations are added inside three scenarios and experimented with our static analysis engine (with three new checkers).

\end{itemize}

 


