\chapter{Related Work}

There are many annotation languages proposed until now for
extending the C type system \cite{ref_54_condit:dependent}, \cite{ref_53_evans:static}, \cite{ref_51_microsoft:sal}, \cite{ref_55_sun:lock}, \cite{ref_56_torvalds:sparse} to be
used during run-time as a new language run-time for PHP and
Python \cite{ref_57_alex:improving} to annotate function interfaces \cite{ref_53_evans:static}, \cite{ref_51_microsoft:sal}, \cite{ref_56_torvalds:sparse} to
annotate models in order to detect information flow bugs \cite{ref_58_iflow:kuzman}
to annotate source code files \cite{ref_59_rosenblum:towards}, \cite{ref_60_rosenblum:practical}, \cite{ref_61_lintan:acomment} or to annotate
control flows \cite{ref_53_evans:static}, \cite{ref_52_splint:flow}, \cite{ref_51_microsoft:sal}.The following annotation languages have made significant impact: Microsoft\'s SAL annotations \cite{ref_51_microsoft:sal} helped to detect more than 1000 potential security vulnerabilities in Windows
code \cite{ref_50_ball:research}. In addition, several other annotation languages including FlowCaml \cite{ref_49_simonet:flowcaml}, Jif \cite{ref_48_chong:jif}, Fable \cite{ref_47_swamy:fable}, AURA \cite{ref_46_jia:aura} and FINE \cite{ref_45_nikhil:fine} express information flow related concerns.

Saner \cite{ref_61_lintan:acomment}, a novel approach to the evaluation of the sanitization process in web applications. The approach relies on two complementary analysis techniques to identify faulty sanitization procedures. Saner \cite{ref_61_lintan:acomment} introduce a dynamic analysis technique that is
able to reconstruct the code that is responsible for
the sanitization of application inputs, and then execute this code on malicious inputs to identify faulty
sanitization procedures. By applying
it to real-world applications, identified novel vulnerabilities that stem from incorrect or incomplete sanitization.

A simple idea named trusted declassification \cite{ref_2_hicks2006trusted} in which special declassifier functions are specified as part of the global policy. In particular, individual principals declaratively specify which declassifiers they trust so that all information flows implied by the policy can be reasoned about in absence of a particular program. They formalize their approach for a Java like language and prove a modified form of noninterference which they call noninterference modulo trusted methods. They have implemented their approach as an extension to Jif and provide some of their experience using it to build a secure e-mail client.

Using RESIN \cite{ref_63_yip2009improving}, Web application programmers can prevent a range
of problems, from SQL injection and cross-site scripting, to inadvertent password disclosure and missing access control checks. Adding
a RESIN assertion to an application requires few changes to the
existing application code, and an assertion can reuse existing code
and data structures. For instance, 23 lines of code detect and prevent
three previously-unknown missing access control vulnerabilities in
phpBB, a popular Web forum application. Other assertions comprising tens of lines of code prevent a range of vulnerabilities in Python
and PHP applications. A prototype of RESIN incurs a 33\% CPU
overhead running the HotCRP conference management application.

UMLSec \cite{ref_33_juerjens:secure} is a model-driven approach that allows the
development of secure applications with UML. Compared with
our approach, UMLSec does neither automatic code
generation nor the annotations can be used for automated
constraints checking.

The detection of information flow errors can be
addressed with dynamic analysis techniques \cite{ref_44_avgerinos:aeg}, \cite{ref_43_fenton:memoryless}, \cite{ref_42_sabelfeld:dynamic},
static analysis techniques \cite{ref_41_guarnieri:security}, \cite{ref_40_myers:jflow}, \cite{ref_39_simonet:report}, \cite{ref_38_volpano:sound}, \cite{ref_37_xiao:transparent} (similar
to our approach with respect to static analysis of code and
tracking of data information flow) and hybrid techniques which
combine static and dynamic approaches \cite{ref_36_moore:static}. Also, extended
static checking \cite{ref_35_david:extended} (ESC) is a promising research area which
tries to cope with the shortage of not having certain program
run-time information.
The static code analysis techniques need to know which
parts of the code are: sinks, sources and which variables
should be tagged. A solution for tagging these elements in
source code is based on a pre-annotated library which contains
all the needed annotations attached to function declarations.
Leino \cite{ref_34_leino:10years} reports about the annotation burden as being very
time consuming and disliked by some programming teams.

 The studies rely on manually
written annotations while our annotation language is integrated
into two editors which are be used to annotate UML state
charts and C code by selecting annotations from a list and
without the need to memorize a new annotation language.

Recently taint modes integrated in programming languages as Camlbased FlowCaml \cite{ref_32_simonet:report}, Ada-based SPARK Examiner \cite{ref_31_chapman:enforcing} and the scripting. However, none of these annotation and programming languages have support for introducing information flow
restrictions in both models and the source code.
Splint \cite{ref_30_david:splint}, Flawfinder \cite{ref_29_wheeler:flawfinder} and Cqual \cite{ref_28_umesh:cqual} are used to
detect information flow bugs in source code and come with
comprehensive user manuals describing how the annotation
language can be used in order to annotate source code.
iFlow \cite{ref_27_iflow:kuzman} is used for detecting information flow bugs in
models and is based on modeling dynamic behavior of the
application using UML sequence diagrams and translating
them into code by analyzing it with JOANA \cite{ref_26_kit:joana}. In comparison with our approach these tools do not use the same
annotation language for annotating UML models and code.
Thus, a user has to learn to use two annotation languages
which can be perceived to be a high burden in some scenarios.


 Heldal et al. \cite{ref_25_heldal:bridging}, \cite{ref_23_heldal:supporting} introduced an
UML profile that incorporates a decentralized label model [40]
into the UML. It allows the annotation of UML artifacts with
Jif \cite{ref_24_myers:descentrelized} labels in order to generate Jif code from the UML
model automatically. However, the Jif-style annotation already
proved to be non-trivial on the code level \cite{ref_22_preibusch2011information}, while \cite{ref_23_heldal:supporting}
notes that the actual automatic Jif code generation is still future
work. These approaches can not be used to annotate both UML
models and code. Moreover, these approaches lack of tools for
automated checking of previously imposed constraints.