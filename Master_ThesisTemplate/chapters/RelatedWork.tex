\chapter{Related Work}

There are many annotation languages proposed until now for
extending the C type system \cite{ref_54_condit:dependent}, \cite{ref_53_evans:static}, \cite{ref_51_microsoft:sal}, \cite{ref_55_sun:lock}, \cite{ref_56_torvalds:sparse} to be
used during run-time as a new language run-time for PHP and
Python \cite{ref_57_alex:improving} to annotate function interfaces \cite{ref_53_evans:static}, \cite{ref_51_microsoft:sal}, \cite{ref_56_torvalds:sparse} to
annotate models in order to detect information flow bugs \cite{ref_58_iflow:kuzman}
to annotate source code files \cite{ref_59_rosenblum:towards}, \cite{ref_60_rosenblum:practical}, \cite{ref_61_lintan:acomment} or to annotate
control flows \cite{ref_53_evans:static}, \cite{ref_52_splint:flow}, \cite{ref_51_microsoft:sal}.The following annotation languages have made significant impact: Microsoft\'s SAL annotations \cite{ref_51_microsoft:sal} helped to detect more than 1000 potential security vulnerabilities in Windows
code \cite{ref_50_ball:research}. In addition, several other annotation languages including FlowCaml \cite{ref_49_simonet:flowcaml}, Jif \cite{ref_48_chong:jif}, Fable \cite{ref_47_swamy:fable}, AURA \cite{ref_46_jia:aura} and FINE \cite{ref_45_nikhil:fine} express information flow related concerns.

UMLSec \cite{ref_33_juerjens:secure} is a model-driven approach that allows the
development of secure applications with UML. Compared with
our approach, UMLSec does neither automatic code
generation nor the annotations can be used for automated
constraints checking.

The detection of information flow errors can be
addressed with dynamic analysis techniques \cite{ref_44_avgerinos:aeg}, \cite{ref_43_fenton:memoryless}, \cite{ref_42_myers:jflow},
static analysis techniques \cite{ref_41_myers:jflow}, \cite{ref_40_myers:jflow}, \cite{ref_39_simonet:report}, \cite{ref_38_volpano:sound}, \cite{ref_37_xiao:transparent} (similar
to our approach with respect to static analysis of code and
tracking of data information flow) and hybrid techniques which
combine static and dynamic approaches \cite{ref_36_moore:static}. Also, extended
static checking \cite{ref_35_david:extended} (ESC) is a promising research area which
tries to cope with the shortage of not having certain program
run-time information.
The static code analysis techniques need to know which
parts of the code are: sinks, sources and which variables
should be tagged. A solution for tagging these elements in
source code is based on a pre-annotated library which contains
all the needed annotations attached to function declarations.
Leino \cite{ref_34_leino:10years} reports about the annotation burden as being very
time consuming and disliked by some programming teams.

 The studies rely on manually
written annotations while our annotation language is integrated
into two editors which are be used to annotate UML state
charts and C code by selecting annotations from a list and
without the need to memorize a new annotation language.

Recently taint modes integrated in programming languages as Camlbased FlowCaml \cite{ref_32_simonet:report}, Ada-based SPARK Examiner \cite{ref_31_chapman:enforcing} and the scripting. However, none of these annotation and programming languages have support for introducing information flow
restrictions in both models and the source code.
Splint \cite{ref_30_david:splint}, Flawfinder \cite{ref_29_wheeler:flawfinder} and Cqual \cite{ref_28_umesh:cqual} are used to
detect information flow bugs in source code and come with
comprehensive user manuals describing how the annotation
language can be used in order to annotate source code.
iFlow \cite{ref_27_iflow:kuzman} is used for detecting information flow bugs in
models and is based on modeling dynamic behavior of the
application using UML sequence diagrams and translating
them into code by analyzing it with JOANA \cite{ref_26_kit:joana}. In comparison with our approach these tools do not use the same
annotation language for annotating UML models and code.
Thus, a user has to learn to use two annotation languages
which can be perceived to be a high burden in some scenarios.


 Heldal et al. \cite{ref_25_heldal:bridging}, \cite{ref_23_heldal:supporting} introduced an
UML profile that incorporates a decentralized label model [40]
into the UML. It allows the annotation of UML artifacts with
Jif \cite{ref_24_myers:descentrelized} labels in order to generate Jif code from the UML
model automatically. However, the Jif-style annotation already
proved to be non-trivial on the code level \cite{ref_22_preibusch2011information}, while \cite{ref_23_heldal:supporting}
notes that the actual automatic Jif code generation is still future
work. These approaches can not be used to annotate both UML
models and code. Moreover, these approaches lack of tools for
automated checking of previously imposed constraints.