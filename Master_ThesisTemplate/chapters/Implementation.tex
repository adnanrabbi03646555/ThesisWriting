\chapter{Implementation}

\section{Complete Workflow of the System:}

\begin{figure}[ht!]
	\begin{tabular}{lll}
		\footnotesize                       
		\textit{Ann\_Lang}           &\footnotesize $::=$         &\footnotesize HeaderModel*;       \\ \\
		
		\footnotesize
		\textit{H\_Model}            &\footnotesize $::=$         &\footnotesize \textit{S\_L\_Anno};       \hfill ;single line comment rule   \\     
		&\footnotesize $\ \vert $    &\footnotesize \textit{M\_L\_Anno};       \hfill ;multi line comment rule    \\ 
		&\footnotesize $\ \vert $    &\footnotesize \textit{Func\_Decl};       \hfill ;function declaration rule  \\ 
		&\footnotesize $\ \vert $    &\footnotesize \textit{Attr\_Def};        \hfill ;variable declaration rule  \\ \\
		\footnotesize  	
		\textit{S\_L\_Anno}          &\footnotesize $::=$         &\footnotesize \textbf{"//@ @function "},    Func\_Type,              [\textbf{H} $\ \vert $  \textbf{L}];     \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"//@ @parameter "},   p\_Name,  Sec\_Type, Var\_Type,    [\textbf{H} $\ \vert $  \textbf{L}];    \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"//@ @variable "},    v\_Name,  Sec\_Type,     [\textbf{H} $\ \vert $  \textbf{L}];    \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"//@ @preStep "},     pr\_s\_Name,             [\textbf{H} $\ \vert $  \textbf{L}];    \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"//@ @postStep "},    po\_s\_Name,             [\textbf{H} $\ \vert $  \textbf{L}];    \\ \\   
		\footnotesize            
		\textit{M\_L\_Anno}          &\footnotesize $::=$         &\footnotesize [\textbf{"/*@ "}],  ["* "],  Func\_Ann,  (\textbf{" @*/"}) \\
		&\footnotesize $\ \vert $    &\footnotesize ("*"), [" "]*, (\textbf{"@*/"});                  \\ \\
		\footnotesize        
		\textit{Func\_Ann}           &\footnotesize $::=$         &\footnotesize \textbf{"@function "},    Func\_Type,              [\textbf{H} $\ \vert $  \textbf{L}];     \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"@parameter "},   p\_Name,  Sec\_Type, Var\_Type,    [\textbf{H} $\ \vert $  \textbf{L}];    \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"@preStep "},     pr\_s\_Name,             [\textbf{H} $\ \vert $  \textbf{L}];    \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{"@postStep "},    po\_s\_Name,             [\textbf{H} $\ \vert $  \textbf{L}];    \\ \\                                        
		\footnotesize                       
		\textit{Func\_Type}          &\footnotesize $::=$        &\footnotesize \textbf{authentication};\\
		&\footnotesize $\ \vert $ &\footnotesize \textbf{declassification}; \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{sanitization};     \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{sink};             \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{source};           \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{trust\_boundary};  \\ \\
		\footnotesize                       
		\textit{Sec\_Type}           &\footnotesize $::=$         &\footnotesize \textbf{confidential}; \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{source};    \\ \\
		\footnotesize                       
		\textit{Var\_Type}           &\footnotesize $::=$         &\footnotesize \textbf{authenticated}; \\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{declassified}
		\\
		&\footnotesize $\ \vert $    &\footnotesize \textbf{sanitized};    \\ \\	
		
	\end{tabular}
	\caption{Light-weight annotation language grammar excerpt}
	\label{language grammar}
\end{figure}


\section{The Grammar of Annotation Language:}

The grammar of annotation language is represented as in Extended Backus Naur Form (EBNF) in figure 4.1 . The following type face conventions were used: Italic font for non-terminals, bold typewriter font for literal terminals including keywords.\\
 
Annotation language grammar has two grammar rules
\texttt{S\_L\_Anno} and \texttt{M\_L\_Anno} used for defining security annotations. The \texttt{Func\_Decl} and \texttt{Attr\_Definition} rules are used to recognize C or C++ function declarations and variable. The \texttt{Var\_Type} rule is used for variable type which is either for authenticated or declassified or sanitized variable. \texttt{Sec\_Type} rule is used for type of security whether a variable is confidential or not. In \texttt{Func\_Decl} rule the type function is declared. A function can be either one of this like authentication, declassification, sanitization, source or sink.\\

As per requirements previous annotation language grammar which is written in xtext language has been extended. Extra annotation have included like \enquote{authenticated}, \enquote{declassified}, \enquote{sanitized}, \enquote{sanitization}, \enquote{declassification}, \enquote{authentication}. Some part of the code snippet of extended xtext grammar is given below.

\begin{lstlisting}
	/**
	* @FunctionAnnotation :used for function annotations
	*/ 
	FunctionAnnotation returns FunctionAnnotation:
	{FunctionAnnotation}( 
	result +=  '@function '   functionType=FunctionType      (' ')?                              (level =('H'|'L'))?     ((name0=ID))? ((nameComment=ID))? ('\n' | '\r')?
	// supported without space before confidential and sensitive
	| '@parameter '   parameter=ID (name0=ID)? (securityType=SecurityType)?(' ')?  (level =('H'|'L'))? ('True'|'False')? (variableTyp=VariableType)?  ((name1=ID))? ((nameComment=ID))? ('\n' | '\r')?	
	;
	
	/**
	* @SingleLineAnnotation :used for adding single line annotations
	*/ 
	SingleLineAnnotation returns SingleLineAnnotation:
	{SingleLineAnnotation}(
	result+=  '//@ @function '    functionType=FunctionType (' ')?                  (level =('H'|'L'))?  ((name0=ID))? ((nameComment=ID))?  ('\n' | '\r')*
	// supported without space before confidential and sensitive
	| '//@ @parameter '   parameter=ID (securityType=SecurityType)? (' ')?  (level =('H'|'L'))? ('True'|'False')? (variableTyp=VariableType)?  ((nameComment=ID))?  ('\n' | '\r')?
	| '//@ @variable '    variable=ID  (securityType=SecurityType)? (' ')?  (level =('H'|'L'))? ('True'|'False')? ((nameComment=ID))?  ('\n' | '\r')?
	
	;
	
	/**
	* @FunctionType :annotaions types for functions
	*/ 
	enum FunctionType: declassification 
	| sanitization
	| authentication
	| sink
	| source
	| trust_boundary
	;
	
	
	/**
	* @Variable Type :annotaions types for function parameters
	*/ 
	enum VariableType: declassified 
	| sanitized
	| authenticated
	;	
\end{lstlisting}

\section{UML State Chart Editor:}

A set of formal representation of UML statecharts is presented in this section. The state identifier and event are represented as S and Event respectively both as set types. For simple specification, the basic set types are used. In the definition of a transition from one state to another the guard is defined as a Boolean type. According to F Alhumaidan state based static and dynamic formal analysis of UML state diagrams \cite{ref_16_alhumaidan2012state} , a state can have three possible values that are active, passive or null represented as Active, Passive and null respectively. The type of state can be simple, concurrent, non-concurrent, initial or final.

\begin{figure}[ht!]
	\begin{tabular}{lll}
		\footnotesize                       
		\textit{[S, Event]}          &\footnotesize \\
		
		\footnotesize
		\textit{Boolean}            &\footnotesize $::=$         &\footnotesize \textit{True} $\ \vert $ {False};       \\   
		\footnotesize
		\textit{Status}            &\footnotesize $::=$         &\footnotesize \textit{Active}
		 $\ \vert $ {Passive}$\ \vert $ {Null};       \\ 
		\footnotesize
		\textit{Type}            &\footnotesize $::=$         &\footnotesize \textit{Simple}
		 	$\ \vert $ {Concurent}$\ \vert $ {Nonconcurent} $\ \vert $ {Initial}$\ \vert $ {Final};       \\
		 	 
		
	\end{tabular}
	\caption{UML Statechart Formal Representation}
	\label{statechart_formal_representation}
\end{figure}
In modeling using sets, it's not imposing any restriction upon the number of elements and a high level of
abstraction is supposed. Further, it's not insist upon any
effective procedure for deciding whether an arbitrary
element is a member of the given collection or not. As a
consequent, sets S and Event are sets over which cannot define any operation of set theory. For example,
cardinality to know the number of elements in a set cannot
be defined. Similarly, the subset, union, intersection or
complement operations over the sets are not defined.\\

The state diagram is a collection of states related by
certain types of relations. In the definition of a state, state identifier, its type, status and set of regions is required.Region is defined as a power set of sequence of states. The state is represented by a schema which consists of four components described above. All these components are
encapsulated and put in the Schema State given below.
The invariants over the schema are defined in the second
part of schema.\\

\begin{figure}[ht!]
	\begin{tabular}{lll}
		\footnotesize                       
		\textit{State}       \\
		
		\footnotesize
		\textit{name}   $:$    \textit{S}  \\   
		\footnotesize
		\textit{type}   $:$    \textit{Type}  \\   
		\footnotesize
		\textit{status}   $:$    \textit{Status}      \\
		\footnotesize
		\textit{regions} $:$   \textit{seq Regions} \\
		
		\footnotesize
		\textit{regions} $=$   \textit{1} $\ \  $ {type}$=$   \textit{Simple} \\
		\footnotesize
		 \textit{\# regions} $=$   \textit{1} $\ \  $ {type}$=$   \textit{Nonconcurrent} \\
		 \textit{\# regions} $=$   \textit{1} $\ \  $ {type}$=$   \textit{Concurent} \\
		 
		
	\end{tabular}
	\caption{UML statechart some other formal representation}
	\label{statechart_formal_representation_part2}
\end{figure}

\textbf{Invariants:}
\begin{itemize}
\item  If there is no region in a state inside the state diagram, then it is a simple state.
\item  If there is exactly one region in a state then it is termed as non-concurrent composite state.
\item  If there are two or more regions in a state then it is
concurrent composite state.
\end{itemize}

The collection of states is represented by the schema
States which consists of four variables. The mapping
substates from State to power set of State describes type
of a state.
 \begin{figure}[ht!]
 	\begin{tabular}{lll}
 		\footnotesize                       
 		\textit{States}          \\
 		\footnotesize                       
 		\textit{start}          
 		$:$  \textit{State}\\
 		
 		\textit{states}          
 		$:$  \textit{State}\\
 		
 		\textit{states}           
 		$:$  \textit{State}\\
 		\footnotesize
 		\textit{substates}            $:$         \textit{State} $\ \  $ {State};       \\   
 		\footnotesize
 		\textit{target}             $:$         \textit{State}    \\
 		 \footnotesize                       
 		 \textit{start}           
 		 $:$  \textit{states}\\
 		  \footnotesize                       
 		  \textit{start}          
 		  $:$ \textit{target}\\
 		   \footnotesize                       
 		   \textit{start}           
 		   $:$  \textit{dom} $\ \  ${substates}\\
 		   
 		   \footnotesize                       
 		   \textit{states}          \\ 		
 		$\ \  $ \textit{s}      $:$     \textit{State} $\ \  $ {s} $\ \  $ \textit{dom} $\ \  ${substates} $\ \  $ {s} $\ \  $ \textit{states}        \\ 
 		$\ \  $ \textit{s}      $:$     \textit{State} $\ \  $ {s} $\ \  $ \textit{states} $\ \  $ {s} $\ \  $ \textit{start} $\ \  $ {s} $\ \  $ \textit{target}$\ \  $ {s.typ}\\ 
 		$\ \  $ \textit{Simple} $\ \  $ {s} $\ \  $ \textit{dom} $\ \  ${substates}\\
 		\footnotesize                       
 		\textit{target}  $\ \  $ \textit{states}        \\ 
 		\footnotesize                       
 		\textit{target}  $\ \  $ \textit{dom} $\ \  ${substates}\\	
 	\end{tabular}
 	\caption{UML Statechart Formal Representation of Invariants}
 	\label{statechart_formal_representation_invariants}
 	\end{figure}

\textbf{Invariants:}
\begin{itemize}
\item The start state is not in the collection of states.
\item The start state is not the target state.
\item The start state does not belong to domain of substates
mapping that is it has no sub-state.
\item The set of states is non-empty.
\item For any state, s, if it is in the states and is not the start or target state and not the simple state then it belongs to domain of sub-states.
\item The target state does not belong to states.
\item The target state of the state diagram does not belong to domain of the sub-states.
\end{itemize}

UML state chart editor has been extended based on the open source Yakindu SCT \cite{ref_15_yakindu:sct}framework. The existing language grammar with
annotation language grammar has extended in order to support new set
of tags. Furthermore, an annotation proposal filter implemented which was used to filter out the annotation language tags of the Yakindu SCT language grammar.\\

\section{Source Code Editor:}
The source code editor has extended which offers annotation language proposals which are context sensitive with respect to the position of the currently edited syntax line.Editor suggestions work only if the whole file is parsed without errors.

\section{C Code Generator:}
C code generator has extended based on Eclipse EMF and xTend which is used to generate the state chart execution code containing the previously added security annotations from UML state charts. The code generator outputs two files per UML state chart (one .c and one
.h file). Generated annotations can reside in both header file
and source code file. Previously annotated UML state chart
states are converted to either C function calls or C variables
declarations, both have been previously annotated. We use
the available state chart execution flow functionality which is
responsible for traversing the UML state chart during state
chart simulation. The UML state chart will be traversed by the code generation algorithm and code is generated based on
the mentioned state chart execution flow. The generated code
will contain at least one bad path (contains a true positive) and
a good path (contains no bug) per UML state chart if those
paths were previously modeled inside the UML state chart.

\section{View Buggy Path in Sequence Diagram}
Through the static analysis engine buggy path can be found as a list of string. Inside the list there are function calls, separate statements like if statements, switch-case statements, variable declaration, assignment of variables etc. of programming language (like C,C++). Then to view the path using java a sequence diagram is generated.
now it easier to trace the buggy path by viewing generated sequence diagram. One sample example of the buggy path is given in figure 4.1.
\begin{figure}[htbp]
	\centering
	\includegraphics{styles/Error_trace_path.jpg}
	\caption{Error trace path in sequence diagram}
\end{figure}
