\chapter{Implementation}

\section{Complete Workflow of the System:}




\section{The Grammar of Annotation Language:}

As per requirements previous annotation language grammar which is written in xtext language has been extended. Extra annotation have included like "@return", "True", "False", "sanitization", "declassification", "authentication". Some the code snippet of extended xtext grammar is given below.
\begin{lstlisting}
	/**
	* @FunctionAnnotation :used for function annotations
	*/ 
	FunctionAnnotation returns FunctionAnnotation:
	{FunctionAnnotation}( 
	result += '@return' (' ')? (level=('H'|'L'))? ('\n' | '\r')?
	);
	
	/**
	* @SingleLineAnnotation :used for adding single line annotations
	*/ 
	SingleLineAnnotation returns SingleLineAnnotation:
	{SingleLineAnnotation}(
	result+= '//@ @parameter 'parameter=ID(securityType=SecurityType)? (' ')?  (level =('H'|'L'))? ('True'|'False')? ((nameComment=ID))?  ('\n' | '\r')?	 
	);
		
	/**
	* @FunctionType :annotaions types for functions
	*/ 
	enum FunctionType: declassification 
	| sanitization
	| authentication
	
\end{lstlisting}

\section{UML State Chart Editor:}
UML state chart editor has been extended based on the open source Yakindu SCT [21]framework. The existing language grammar with
annotation language grammar has extended in order to support new set
of tags. Furthermore, an annotation proposal filter implemented which was used to filter out the annotation language tags of the Yakindu SCT language grammar.

\section{Source Code Editor:}
The source code editor has extended which offers annotation language proposals which are context sensitive with respect to the position of the currently edited syntax line.Editor suggestions work only if the whole file is parsed without errors.

\section{C Code Generator:}
C code generator has extended based on Eclipse EMF and xTend which is used to generate the state chart execution code containing the previously added security annotations from UML state charts. The code generator outputs two files per UML state chart (one .c and one
.h file). Generated annotations can reside in both header file
and source code file. Previously annotated UML state chart
states are converted to either C function calls or C variables
declarations, both have been previously annotated. We use
the available state chart execution flow functionality which is
responsible for traversing the UML state chart during state
chart simulation. The UML state chart will be traversed by the code generation algorithm and code is generated based on
the mentioned state chart execution flow. The generated code
will contain at least one bad path (contains a true positive) and
a good path (contains no bug) per UML state chart if those
paths were previously modeled inside the UML state chart.

\section{View Buggy Path in Sequence Diagram}
Through the static analysis engine buggy path can be found as a list of string. Inside the list there are function calls, separate statements like if statements, switch-case statements, variable declaration, assignment of variables etc. of programming language (like C,C++). Then to view the path using java a sequence diagram is generated.
now it easier to trace the buggy path by viewing generated sequence diagram. One sample example of the buggy path is given in figure 4.1.
\begin{figure}[htbp]
	\centering
	\includegraphics{styles/Error_trace_path.jpg}
	\caption{Error trace path in sequence diagram}
\end{figure}
