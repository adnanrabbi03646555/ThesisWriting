\chapter{Conclusion and Future Work}

In the conclusion and future work we will present the conclusion and possible future work of this research.

\section{Conclusion}
A keyword-based annotation language that can be used out of the box for annotating UML state charts and C code in two software development phases by providing two editors for inserting security annotations in order to detect information flow bugs automatically. It is evaluated on some sample programs and showed that this approach is applicable to real life scenarios.

Functions are used to declassify sensitive data because they are trusted to release information. Our work introduces a security-typed language. We annotate functions with security levels. Functions may be annotated with a high security level; this indicates they are trusted and permits them to serve as a safe mechanism for declassification.

Web applications perform a lot of critical tasks and
handle sensitive information. Even though there have been
a number of research efforts to identify the use of unvalidated input in web applications, little has been done
to characterize how sanitization is actually performed and
how effective it is in blocking web-based attacks. In case of desktop applications it is not easy to handle sensitive information. To handle these sensitive information and invalidate insecure input data a good approach to the evaluation of the sanitization process has been developed. Future work will focus on the analysis of type-based validation procedures.

Mechanisms such as access control, encryption, firewalls, digital
signatures and antivirus scanning do not address the fundamental
problem: tracking the flow of information in computing
systems. Run-time monitoring of operating-systems calls is
similarly of limited use because information-flow policies are
not properties of a single execution; in general, they require
monitoring all possible execution paths. On the other hand,
there is clear evidence of benefits provided by language-based
security mechanisms that build on technology for static analysis
and language semantics. Type systems are attractive for
implementing static security analyses. It is natural to augment
type annotations with security labels. Type systems allow for
compositional reasoning, which is a necessity for scalability
when applied to larger programs. Semantics-based models
are suitable for describing end-to-end policies such as
noninterference and its extensions. These models allow for a
precise formulation of the attacker's view of the system. This
view is described as a relation on program behaviors where
two behaviors are related if they are not distinguishable by
the attacker. Attackers of varying capabilities can be modeled
straightforwardly as different attacker views, and correspond
to different security properties. A number of further advantages are
associated with both security-type systems and semantics based
security. Compositionality is especially valuable in the
context of security properties.Compositionality
greatly facilitates correctness proofs for program analyses. If the recent
progress in language-based techniques for soundly enforcing
end-to-end confidentiality policies continues, the approach
may soon become an important part of standard security
practice.

Last but not least, it is a system which is usable for specifying information flow security constraints which can be used in the design and coding phase in order to detect information flow bugs.

\section{ Future Work}
In future it can be extended for source code editor as
a pop-up window based proposal editor used to add/retrieve
annotation to/from a library. The definition of new language
annotation tags should be possible from the same window by
providing two running modes (language extension mode and
annotation mode). The envisaged result is to reduce the gap
between annotations insertion/retrieval and the definition of
new language tags. This would help to create personalized
annotated libraries which can be collaboratively annotated if
needed.

Currently code generator, UML statechart modeling developed only for windows operating system. In future code generator, state chart editor should be implemented for other operating systems. Another avenue of future work lies in expanding the policy
language. It is currently very simple, but could be more expressive. For example, constraints could be added to indicate negative information flows. Policy analyses could also be used to determine whether separation of duties is maintained between two principals. When integrity is added to policy language, it could be expanded with robustness constraints. It is a general problem in language based security that there is too little experience with security-typed programming to help guide such research as designing the best form of declassification. We hope that our implementation of this mechanism will help to promote more practical experience with declassifiers which will be implemented in future research.



