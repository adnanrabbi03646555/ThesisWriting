\chapter{Limitations, Conclusion and Future Work}

In the limitations, conclusion and future work we will present the limitations of our research, conclusion and possible future work of this research.


\section{Limitations}
The main limitations of this system are given below:
\begin{itemize}
	\item \textbf{Function calls and statements are possible to model in state chart editor:} Now in UML state chart the user can model function calls and statements e.g. variable declaration of C/C++ language. But it is not possible to model switch-case statements, loops etc. In future it may be included.
	
	\item \textbf{Region names are fixed:} To model the source code user have to include some regions as per the characteristics of state chart. Inside the region the user can add states, transition, composite states, final state, initial state etc. But according to this research now user can declare two regions. Currently user have to model a real life system using region name good\_path() and bad\_path() or one of them in UML state chart editor. Otherwise code generator will not work. With these two region user can model the source code of a real system as a UML state chart. 
	
	\item \textbf{Generator generates two files:} After modeling the source code as UML state charts need to generate the code from the model. The generator was built with Eclipse xtend. Generator included inside YAKINDU SCT Editor.Now code generator generates only two files. One is .c file and another one is .h file.
	
	\item \textbf{Generator included inside YAKINDU SCT editor:} As an open source tool here for this research we chose YAKINDU SCT Editor to model the source code into state charts. Inside the YAKINDU SCT Editor code generator also exist for C and C++ language. We developed the source code generator according to the requirements inside Myc package for C code generation. Now code generator works with YAKINDU SCT editor.
	
	
	\item \textbf{Bindings with operating system:}  Code generator, UML statechart modeling developed in windows operating system. Both of these are now working only in windows operating system.
	
	\item \textbf{Simulation not working:} The simulation for statemachine is working for normal state chart. But the simulation of UML statechart is not currently working in selected scenarios in state chart editor.
	
	\item \textbf{Fixed function names:} For this research we had to add some more type of functions e.g., authentication, declassification and santization to annotate the UML state chart as well as source code. These three types of function have been included inside the annotation language grammar. Now source, sink, authentication, declassification and santization types of function can be annotated. So, user's can now be able to annotate only these type of functions not more than that.
	
\end{itemize}

\section{Conclusion}
A keyword-based annotation language that can be used out of the box for annotating UML state charts and C code in two software development phases by providing two editors for inserting security annotations in order to detect information flow bugs automatically. It is evaluated on some sample programs and showed that this approach is applicable to real life scenarios.

Functions are used to declassify sensitive data because they are trusted to release information. Our work introduces a security-typed language. We annotate functions with security levels. Functions may be annotated with a high security level; this indicates they are trusted and permits them to serve as a safe mechanism for declassification.

Web applications perform a lot of critical tasks and
handle sensitive information. Even though there have been
a number of research efforts to identify the use of unvalidated input in web applications, little has been done
to characterize how sanitization is actually performed and
how effective it is in blocking web-based attacks. In case of desktop applications it is not easy to handle sensitive information. To handle these sensitive information and invalidate insecure input data a good approach to the evaluation of the sanitization process has been developed. Future work will focus on the analysis of type-based validation procedures.

Mechanisms such as access control, encryption, firewalls, digital
signatures and antivirus scanning do not address the fundamental
problem: tracking the flow of information in computing
systems. Run-time monitoring of operating-systems calls is
similarly of limited use because information-flow policies are
not properties of a single execution; in general, they require
monitoring all possible execution paths. On the other hand,
there is clear evidence of benefits provided by language-based
security mechanisms that build on technology for static analysis
and language semantics. Type systems are attractive for
implementing static security analyses. It is natural to augment
type annotations with security labels. Type systems allow for
compositional reasoning, which is a necessity for scalability
when applied to larger programs. Semantics-based models
are suitable for describing end-to-end policies such as
noninterference and its extensions. These models allow for a
precise formulation of the attacker's view of the system. This
view is described as a relation on program behaviors where
two behaviors are related if they are not distinguishable by
the attacker. Attackers of varying capabilities can be modeled
straightforwardly as different attacker views, and correspond
to different security properties. A number of further advantages are
associated with both security-type systems and semantics based
security. Compositionality is especially valuable in the
context of security properties.Compositionality
greatly facilitates correctness proofs for program analyses. If the recent
progress in language-based techniques for soundly enforcing
end-to-end confidentiality policies continues, the approach
may soon become an important part of standard security
practice.

Last but not least, it is a system which is usable for specifying information flow security constraints which can be used in the design and coding phase in order to detect information flow bugs.

\section{Future Work}
In future this system can be extended for source code editor as
a pop-up window based proposal editor to add/retrieve
annotation to/from a library. The definition of new language
annotation tags should be possible from the same window by
providing two running modes (language extension mode and
annotation mode). The envisaged result is to reduce the gap
between annotations insertion/retrieval and the definition of
new language tags. This would help to create personalized
annotated libraries which can be collaboratively annotated if
needed.

Currently code generator, UML statechart modeling developed only for windows operating system. In future code generator, state chart editor can be implemented for other operating systems. Another avenue of future work lies in expanding the policy language. It is currently very simple, but could be more expressive. For example, constraints could be added to indicate negative information flows. Policy analyses could also be used to determine whether separation of duties is maintained between two principals. When integrity is added to policy language, it could be expanded with robustness constraints. It is a general problem in language based security that there is too little experience with security-typed programming to help guide such research as designing the best form of declassification. We hope that our implementation of this mechanism will help to promote more practical experience with declassifiers and sanitizers.



